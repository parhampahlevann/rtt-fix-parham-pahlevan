#!/bin/bash

# Global Configuration
SCRIPT_NAME="Ultimate Network Optimizer PRO"
SCRIPT_VERSION="11.1"
AUTHOR="Parham Pahlevan"
CONFIG_FILE="/etc/network_optimizer.conf"
LOG_FILE="/var/log/network_optimizer.log"
BACKUP_DIR="/var/lib/network_optimizer"
NETWORK_INTERFACES=($(ls /sys/class/net | grep -v lo))
DEFAULT_MTU=1500
[ -f /proc/xen/xenbus ] && DEFAULT_MTU=1450
CURRENT_MTU=$(cat /sys/class/net/${NETWORK_INTERFACES[0]}/mtu 2>/dev/null || echo $DEFAULT_MTU)
DNS_SERVERS=("1.1.1.1" "8.8.8.8")
CURRENT_DNS=$(grep nameserver /etc/resolv.conf 2>/dev/null | awk '{print $2}' | tr '\n' ' ')
KERNEL_VERSION=$(uname -r | cut -d'-' -f1)
SAFE_REBOOT=false

# Initialize system
mkdir -p "$BACKUP_DIR" "$(dirname "$LOG_FILE")"
exec > >(tee -a "$LOG_FILE") 2>&1

# Color Codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'
BOLD='\033[1m'

# Save Configuration
save_config() {
    cat > "$CONFIG_FILE" <<EOL
# Network Optimizer Configuration
NETWORK_INTERFACES=("${NETWORK_INTERFACES[@]}")
MTU=$CURRENT_MTU
DNS_SERVERS=(${DNS_SERVERS[@]})
EOL
    chmod 600 "$CONFIG_FILE"
}

# Load Configuration
load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        source "$CONFIG_FILE"
        [ -n "$MTU" ] && CURRENT_MTU=$MTU
        [ -n "$DNS_SERVERS" ] && DNS_SERVERS=(${DNS_SERVERS[@]})
        [ ${#NETWORK_INTERFACES[@]} -gt 0 ] || NETWORK_INTERFACES=($(ls /sys/class/net | grep -v lo))
    fi
}

# Apply persistent settings
apply_persistent_settings() {
    # MTU
    for iface in "${NETWORK_INTERFACES[@]}"; do
        if ip link show "$iface" >/dev/null 2>&1; then
            ip link set dev "$iface" mtu "$CURRENT_MTU" 2>/dev/null || CURRENT_MTU=$DEFAULT_MTU
            
            if [[ -d /etc/netplan ]]; then
                local netplan_file=$(ls /etc/netplan/*.yaml | head -n1)
                [ -f "$netplan_file" ] && {
                    cp "$netplan_file" "$BACKUP_DIR/netplan_$(date +%s).yaml"
                    if ! grep -q "mtu: $CURRENT_MTU" "$netplan_file" && grep -q "$iface:" "$netplan_file"; then
                        sed -i "/$iface:/a\      mtu: $CURRENT_MTU" "$netplan_file" || {
                            cp "$BACKUP_DIR/netplan_$(ls -t "$BACKUP_DIR/netplan_*.yaml" | head -1)" "$netplan_file"
                        }
                        netplan apply >/dev/null 2>&1 || {
                            cp "$BACKUP_DIR/netplan_$(ls -t "$BACKUP_DIR/netplan_*.yaml" | head -1)" "$netplan_file"
                            netplan apply >/dev/null 2>&1
                        }
                    fi
                }
            elif [[ -f /etc/network/interfaces ]]; then
                local interfaces_file="/etc/network/interfaces"
                cp "$interfaces_file" "$BACKUP_DIR/interfaces_$(date +%s).bak"
                if grep -q "iface $iface" "$interfaces_file"; then
                    if ! grep -q "mtu $CURRENT_MTU" "$interfaces_file"; then
                        sed -i "/iface $iface inet /a\    mtu $CURRENT_MTU" "$interfaces_file" || {
                            cp "$BACKUP_DIR/interfaces_$(ls -t "$BACKUP_DIR/interfaces_*.bak" | head -1)" "$interfaces_file"
                        }
                    fi
                else
                    echo "" >> "$interfaces_file"
                    echo "iface $iface inet dhcp" >> "$interfaces_file"
                    echo "    mtu $CURRENT_MTU" >> "$interfaces_file"
                fi
                systemctl restart networking >/dev/null 2>&1 || {
                    cp "$BACKUP_DIR/interfaces_$(ls -t "$BACKUP_DIR/interfaces_*.bak" | head -1)" "$interfaces_file"
                    systemctl restart networking >/dev/null 2>&1
                }
            fi
        fi
    done

    # DNS
    if [ ${#DNS_SERVERS[@]} -gt 0 ]; then
        if systemctl is-active --quiet systemd-resolved; then
            for iface in "${NETWORK_INTERFACES[@]}"; do
                resolvectl dns "$iface" "${DNS_SERVERS[@]}" >/dev/null 2>&1 || {
                    DNS_SERVERS=("1.1.1.1")
                    resolvectl dns "$iface" "1.1.1.1" >/dev/null 2>&1
                }
            done
        else
            echo "# Generated by $SCRIPT_NAME" > /etc/resolv.conf
            for dns in "${DNS_SERVERS[@]}"; do
                echo "nameserver $dns" >> /etc/resolv.conf
            done
            chmod 644 /etc/resolv.conf
        fi
        CURRENT_DNS="${DNS_SERVERS[*]}"
    fi
}

# Header Display
show_header() {
    clear
    echo -e "${BLUE}${BOLD}╔════════════════════════════════════════════════╗"
    echo -e "║   ${SCRIPT_NAME} ${SCRIPT_VERSION} - ${AUTHOR}         ║"
    echo -e "╚════════════════════════════════════════════════╝${NC}"
    echo -e "${YELLOW}Interfaces: ${BOLD}${NETWORK_INTERFACES[*]}${NC}"
    echo -e "${YELLOW}Current MTU: ${BOLD}$CURRENT_MTU${NC}"
    echo -e "${YELLOW}Current DNS: ${BOLD}$CURRENT_DNS${NC}"

    # BBR Status
    local bbr_status=$(sysctl net.ipv4.tcp_congestion_control 2>/dev/null | awk '{print $3}')
    [ "$bbr_status" == "bbr" ] && echo -e "${YELLOW}BBR Status: ${GREEN}Enabled${NC}" || echo -e "${YELLOW}BBR Status: ${RED}Disabled${NC}"

    # Firewall Status
    if command -v ufw >/dev/null 2>&1; then
        local fw_status=$(ufw status | grep -o "active")
        echo -e "${YELLOW}Firewall Status: ${BOLD}${fw_status:-inactive}${NC}"
    else
        echo -e "${YELLOW}Firewall Status: ${BOLD}Not detected${NC}"
    fi

    # ICMP Status
    local icmp_status=$(iptables -L INPUT -n 2>/dev/null | grep "icmp" | grep -o "DROP")
    [ "$icmp_status" == "DROP" ] && echo -e "${YELLOW}ICMP Ping: ${RED}Blocked${NC}" || echo -e "${YELLOW}ICMP Ping: ${GREEN}Allowed${NC}"

    # IPv6 Status
    local ipv6_status=$(sysctl net.ipv6.conf.all.disable_ipv6 2>/dev/null | awk '{print $3}')
    [ "$ipv6_status" == "1" ] && echo -e "${YELLOW}IPv6: ${RED}Disabled${NC}" || echo -e "${YELLOW}IPv6: ${GREEN}Enabled${NC}"
    echo
}

# Check Root
check_root() {
    [ $EUID -ne 0 ] && { echo -e "${RED}Error: This script must be run as root!${NC}"; exit 1; }
}

# Test Connectivity
_test_connectivity() {
    local targets=("1.1.1.1" "8.8.8.8")
    for target in "${targets[@]}"; do
        ping -c 2 -W 3 "$target" >/dev/null 2>&1 && return 0
    done
    return 1
}

# Ping with Custom MTU
ping_mtu() {
    read -p "Enter MTU size to test (e.g., 1420): " test_mtu
    if [[ "$test_mtu" =~ ^[0-9]+$ ]] && [ "$test_mtu" -ge 68 ] && [ "$test_mtu" -le 9000 ]; then
        echo -e "${YELLOW}Testing ping with MTU=$test_mtu...${NC}"
        ping -M do -s $((test_mtu - 28)) -c 4 1.1.1.1
    else
        echo -e "${RED}Invalid MTU value (must be 68-9000)!${NC}"
    fi
}

# Validate MTU
validate_mtu() {
    local mtu=$1
    ping -M do -s $((mtu - 28)) -c 2 1.1.1.1 >/dev/null 2>&1 || {
        echo -e "${RED}MTU $mtu is not supported by the network${NC}"
        return 1
    }
}

# Configure MTU
configure_mtu() {
    local new_mtu=$1
    local old_mtu=$CURRENT_MTU

    [[ "$new_mtu" =~ ^[0-9]+$ ]] && [ "$new_mtu" -ge 68 ] && [ "$new_mtu" -le 9000 ] || {
        echo -e "${RED}MTU must be between 68 and 9000!${NC}"
        return 1
    }

    validate_mtu "$new_mtu" || return 1

    local backup_file="$BACKUP_DIR/mtu_backup_$(date +%s).conf"
    ip -o link show > "$backup_file"

    for iface in "${NETWORK_INTERFACES[@]}"; do
        ip link set dev "$iface" mtu "$new_mtu" || {
            echo -e "${RED}Failed to set temporary MTU for $iface!${NC}"
            for riface in "${NETWORK_INTERFACES[@]}"; do ip link set dev "$riface" mtu "$old_mtu" 2>/dev/null; done
            return 1
        }
    done

    _test_connectivity || {
        echo -e "${RED}Connectivity test failed! Rolling back MTU...${NC}"
        for iface in "${NETWORK_INTERFACES[@]}"; do ip link set dev "$iface" mtu "$old_mtu" 2>/dev/null; done
        /usr/local/bin/network_emergency_recovery
        return 1
    }

    if [[ -d /etc/netplan ]]; then
        local netplan_file=$(ls /etc/netplan/*.yaml | head -n1)
        [ -f "$netplan_file" ] && {
            cp "$netplan_file" "$BACKUP_DIR/netplan_$(date +%s).yaml"
            local updated=false
            for iface in "${NETWORK_INTERFACES[@]}"; do
                if grep -q "$iface:" "$netplan_file" && ! grep -q "mtu: $new_mtu" "$netplan_file"; then
                    sed -i "/$iface:/a\      mtu: $new_mtu" "$netplan_file" || {
                        echo -e "${RED}Failed to update netplan file for $iface${NC}"
                        cp "$BACKUP_DIR/netplan_$(ls -t "$BACKUP_DIR/netplan_*.yaml" | head -1)" "$netplan_file"
                        return 1
                    }
                    updated=true
                fi
            done
            if $updated; then
                netplan apply >/dev/null 2>&1 || {
                    echo -e "${RED}Failed to apply netplan! Restoring backup...${NC}"
                    cp "$BACKUP_DIR/netplan_$(ls -t "$BACKUP_DIR/netplan_*.yaml" | head -1)" "$netplan_file"
                    netplan apply >/dev/null 2>&1
                    return 1
                }
            fi
        }
    elif [[ -f /etc/network/interfaces ]]; then
        local interfaces_file="/etc/network/interfaces"
        cp "$interfaces_file" "$BACKUP_DIR/interfaces_$(date +%s).bak"
        local updated=false
        for iface in "${NETWORK_INTERFACES[@]}"; do
            if grep -q "iface $iface" "$interfaces_file"; then
                if ! grep -q "mtu $new_mtu" "$interfaces_file"; then
                    sed -i "/iface $iface inet /a\    mtu $new_mtu" "$interfaces_file" || {
                        echo -e "${RED}Failed to update interfaces file for $iface${NC}"
                        cp "$BACKUP_DIR/interfaces_$(ls -t "$BACKUP_DIR/interfaces_*.bak" | head -1)" "$interfaces_file"
                        return 1
                    }
                    updated=true
                fi
            else
                echo "" >> "$interfaces_file"
                echo "iface $iface inet dhcp" >> "$interfaces_file"
                echo "    mtu $new_mtu" >> "$interfaces_file"
                updated=true
            fi
        done
        if $updated; then
            systemctl restart networking >/dev/null 2>&1 || {
                echo -e "${RED}Failed to restart networking! Restoring backup...${NC}"
                cp "$BACKUP_DIR/interfaces_$(ls -t "$BACKUP_DIR/interfaces_*.bak" | head -1)" "$interfaces_file"
                systemctl restart networking >/dev/null 2>&1
                return 1
            }
        fi
    fi

    CURRENT_MTU=$new_mtu
    save_config
    echo -e "${GREEN}MTU successfully set to $new_mtu (persistent after reboot)${NC}"
    return 0
}

# Update DNS Configuration
update_dns() {
    local working_dns=()
    for dns in "${DNS_SERVERS[@]}"; do
        if [[ "$dns" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            timeout 2 dig +short @$dns google.com >/dev/null 2>&1 && working_dns+=("$dns") || \
            echo -e "${YELLOW}Warning: DNS server $dns is not responding${NC}"
        else
            echo -e "${YELLOW}Warning: DNS server $dns has invalid format${NC}"
        fi
    done

    [ ${#working_dns[@]} -eq 0 ] && {
        echo -e "${RED}Error: No valid DNS servers found! Using default 1.1.1.1${NC}"
        working_dns=("1.1.1.1")
    }

    DNS_SERVERS=("${working_dns[@]}")

    local backup_file="$BACKUP_DIR/resolv.conf.bak.$(date +%s)"
    [ -f /etc/resolv.conf ] && cp /etc/resolv.conf "$backup_file" 2>/dev/null

    local dns_applied=false
    if systemctl is-active --quiet systemd-resolved; then
        [ ! -L /etc/resolv.conf ] && {
            rm -f /etc/resolv.conf
            ln -sf /run/systemd/resolve/stub-resolv.conf /etc/resolv.conf 2>/dev/null
        }
        for iface in "${NETWORK_INTERFACES[@]}"; do
            resolvectl dns "$iface" "${DNS_SERVERS[@]}" >/dev/null 2>&1 && dns_applied=true || \
            echo -e "${RED}Failed to set DNS via systemd-resolved for $iface${NC}"
        done
    else
        echo "# Generated by $SCRIPT_NAME" > /etc/resolv.conf
        for dns in "${DNS_SERVERS[@]}"; do
            echo "nameserver $dns" >> /etc/resolv.conf
        done
        chmod 644 /etc/resolv.conf
        dns_applied=true
    fi

    local resolution_success=false
    for dns in "${DNS_SERVERS[@]}"; do
        timeout 2 dig +short @$dns google.com >/dev/null 2>&1 && resolution_success=true && break
    done

    $resolution_success && _test_connectivity || {
        echo -e "${RED}DNS resolution or connectivity test failed! Restoring safe DNS settings...${NC}"
        [ -f "$backup_file" ] && cp "$backup_file" /etc/resolv.conf 2>/dev/null || \
        echo "nameserver 1.1.1.1" > /etc/resolv.conf
        DNS_SERVERS=("1.1.1.1")
        if systemctl is-active --quiet systemd-resolved; then
            for iface in "${NETWORK_INTERFACES[@]}"; do
                resolvectl dns "$iface" "1.1.1.1" >/dev/null 2>&1
            done
        fi
        chmod 644 /etc/resolv.conf
        dns_applied=false
        echo -e "${YELLOW}Reverted to default DNS (1.1.1.1)${NC}"
    }

    if $dns_applied; then
        CURRENT_DNS="${DNS_SERVERS[*]}"
        save_config
        echo -e "${GREEN}DNS servers updated successfully (persistent after reboot)${NC}"
    else
        echo -e "${RED}Failed to apply DNS settings${NC}"
        /usr/local/bin/network_emergency_recovery
        return 1
    fi
}

# Enhanced BBR Installation
install_bbr() {
    echo -e "\n${YELLOW}Checking BBR requirements...${NC}"
    
    if printf '%s\n%s\n' "4.9" "$KERNEL_VERSION" | sort -V -C 2>/dev/null; then
        echo -e "${RED}Your kernel version ($KERNEL_VERSION) is too old for BBR (requires 4.9+)${NC}"
        return 1
    fi

    lsmod | grep -q tcp_bbr || {
        modprobe tcp_bbr 2>/dev/null || {
            echo -e "${RED}BBR is not supported by this kernel!${NC}"
            return 1
        }
    }

    for iface in "${NETWORK_INTERFACES[@]}"; do
        tc qdisc show dev "$iface" | grep -q fq || {
            tc qdisc add dev "$iface" root fq 2>/dev/null || {
                echo -e "${RED}Fair Queue (fq) qdisc is not supported on $iface!${NC}"
                return 1
            }
            tc qdisc del dev "$iface" root fq 2>/dev/null
        }
    done

    cp /etc/sysctl.conf "$BACKUP_DIR/sysctl.conf.bak.$(date +%s)"

    local sysctl_params=(
        "net.core.default_qdisc=fq"
        "net.ipv4.tcp_congestion_control=bbr"
    )

    for param in "${sysctl_params[@]}"; do
        sysctl -w "$param" >/dev/null 2>&1 || {
            echo -e "${RED}Failed to set $param!${NC}"
            cp "$BACKUP_DIR/sysctl.conf.bak.$(ls -t "$BACKUP_DIR/sysctl.conf.bak.*" | head -1)" /etc/sysctl.conf
            sysctl -p >/dev/null 2>&1
            /usr/local/bin/network_emergency_recovery
            return 1
        }
    done

    _test_connectivity || {
        echo -e "${RED}Connectivity lost after applying BBR settings! Restoring previous settings...${NC}"
        cp "$BACKUP_DIR/sysctl.conf.bak.$(ls -t "$BACKUP_DIR/sysctl.conf.bak.*" | head -1)" /etc/sysctl.conf
        sysctl -p >/dev/null 2>&1
        /usr/local/bin/network_emergency_recovery
        return 1
    }

    {
        echo "# BBR Optimization"
        for param in "${sysctl_params[@]}"; do
            echo "$param"
        done
    } >> /etc/sysctl.conf

    sysctl -p >/dev/null 2>&1 || {
        echo -e "${RED}Error applying BBR settings persistently! Restoring backup...${NC}"
        cp "$BACKUP_DIR/sysctl.conf.bak.$(ls -t "$BACKUP_DIR/sysctl.conf.bak.*" | head -1)" /etc/sysctl.conf
        sysctl -p >/dev/null 2>&1
        /usr/local/bin/network_emergency_recovery
        return 1
    }

    local current_cc=$(sysctl net.ipv4.tcp_congestion_control | awk '{print $3}')
    if [[ "$current_cc" == "bbr" ]]; then
        echo -e "${GREEN}BBR successfully installed${NC}"
        return 0
    else
        echo -e "${RED}Failed to enable BBR!${NC}"
        cp "$BACKUP_DIR/sysctl.conf.bak.$(ls -t "$BACKUP_DIR/sysctl.conf.bak.*" | head -1)" /etc/sysctl.conf
        sysctl -p >/dev/null 2>&1
        /usr/local/bin/network_emergency_recovery
        return 1
    fi
}

# Firewall Management
manage_firewall() {
    while true; do
        echo -e "\n${YELLOW}Firewall Management${NC}"
        echo -e "1) Enable Firewall"
        echo -e "2) Disable Firewall"
        echo -e "3) Open Port"
        echo -e "4) Close Port"
        echo -e "5) List Open Ports"
        echo -e "6) Back to Main Menu"
        
        read -p "Enter your choice [1-6]: " fw_choice
        
        case $fw_choice in
            1)
                command -v ufw >/dev/null 2>&1 && {
                    ufw enable
                    echo -e "${GREEN}UFW firewall has been enabled${NC}"
                } || echo -e "${RED}UFW not detected!${NC}"
                ;;
            2)
                command -v ufw >/dev/null 2>&1 && {
                    ufw disable
                    echo -e "${GREEN}UFW firewall has been disabled${NC}"
                } || echo -e "${RED}UFW not detected!${NC}"
                ;;
            3)
                read -p "Enter port number to open (e.g., 22): " port
                [[ "$port" =~ ^[0-9]+$ ]] && [ "$port" -ge 1 ] && [ "$port" -le 65535 ] || {
                    echo -e "${RED}Invalid port number (1-65535)!${NC}"
                    continue
                }
                
                read -p "Enter protocol (tcp/udp, default is tcp): " protocol
                protocol=${protocol:-tcp}
                
                [[ "$protocol" == "tcp" || "$protocol" == "udp" ]] || {
                    echo -e "${RED}Protocol must be tcp or udp!${NC}"
                    continue
                }
                
                command -v ufw >/dev/null 2>&1 && {
                    ufw allow $port/$protocol
                    echo -e "${GREEN}Port $port/$protocol has been opened in UFW${NC}"
                } || echo -e "${RED}UFW not detected!${NC}"
                ;;
            4)
                read -p "Enter port number to close (e.g., 22): " port
                [[ "$port" =~ ^[0-9]+$ ]] && [ "$port" -ge 1 ] && [ "$port" -le 65535 ] || {
                    echo -e "${RED}Invalid port number (1-65535)!${NC}"
                    continue
                }
                
                read -p "Enter protocol (tcp/udp, default is tcp): " protocol
                protocol=${protocol:-tcp}
                
                [[ "$protocol" == "tcp" || "$protocol" == "udp" ]] || {
                    echo -e "${RED}Protocol must be tcp or udp!${NC}"
                    continue
                }
                
                command -v ufw >/dev/null 2>&1 && {
                    ufw deny $port/$protocol
                    echo -e "${GREEN}Port $port/$protocol has been closed in UFW${NC}"
                } || echo -e "${RED}UFW not detected!${NC}"
                ;;
            5)
                command -v ufw >/dev/null 2>&1 && {
                    echo -e "\n${YELLOW}UFW Open Ports:${NC}"
                    ufw status verbose
                } || echo -e "${RED}UFW not detected!${NC}"
                ;;
            6)
                return
                ;;
            *)
                echo -e "${RED}Invalid option!${NC}"
                ;;
        esac
        
        read -p "Press [Enter] to continue..."
    done
}

# Reset Network Settings
reset_network() {
    echo -e "\n${YELLOW}Resetting network settings...${NC}"
    if [[ -d /etc/netplan ]]; then
        netplan apply >/dev/null 2>&1
    elif [[ -f /etc/network/interfaces ]]; then
        systemctl restart networking >/dev/null 2>&1
    fi
    echo -e "${GREEN}Network services have been restarted${NC}"
}

# ICMP Ping Management
manage_icmp() {
    while true; do
        echo -e "\n${YELLOW}ICMP Ping Management${NC}"
        echo -e "1) Block ICMP Ping (Disable Ping)"
        echo -e "2) Allow ICMP Ping (Enable Ping)"
        echo -e "3) Back to Main Menu"
        
        read -p "Enter your choice [1-3]: " icmp_choice
        
        case $icmp_choice in
            1)
                iptables -A INPUT -p icmp --icmp-type echo-request -j DROP
                echo -e "${GREEN}ICMP Ping is now BLOCKED!${NC}"
                ;;
            2)
                iptables -D INPUT -p icmp --icmp-type echo-request -j DROP 2>/dev/null
                echo -e "${GREEN}ICMP Ping is now ALLOWED!${NC}"
                ;;
            3)
                return
                ;;
            *)
                echo -e "${RED}Invalid option!${NC}"
                ;;
        esac
        
        read -p "Press [Enter] to continue..."
    done
}

# IPv6 Management
manage_ipv6() {
    while true; do
        echo -e "\n${YELLOW}IPv6 Management${NC}"
        echo -e "1) Disable IPv6"
        echo -e "2) Enable IPv6"
        echo -e "3) Back to Main Menu"
        
        read -p "Enter your choice [1-3]: " ipv6_choice
        
        case $ipv6_choice in
            1)
                sysctl -w net.ipv6.conf.all.disable_ipv6=1 >/dev/null
                sysctl -w net.ipv6.conf.default.disable_ipv6=1 >/dev/null
                echo -e "${GREEN}IPv6 has been DISABLED!${NC}"
                ;;
            2)
                sysctl -w net.ipv6.conf.all.disable_ipv6=0 >/dev/null
                sysctl -w net.ipv6.conf.default.disable_ipv6=0 >/dev/null
                echo -e "${GREEN}IPv6 has been ENABLED!${NC}"
                ;;
            3)
                return
                ;;
            *)
                echo -e "${RED}Invalid option!${NC}"
                ;;
        esac
        
        read -p "Press [Enter] to continue..."
    done
}

# IPTable Tunnel Setup
manage_tunnel() {
    while true; do
        echo -e "\n${YELLOW}IPTable Tunnel Setup${NC}"
        echo -e "1) Route Iranian IPs directly"
        echo -e "2) Route Foreign IPs via VPN/Gateway"
        echo -e "3) Reset IPTable Rules"
        echo -e "4) Back to Main Menu"
        
        read -p "Enter your choice [1-4]: " tunnel_choice
        
        case $tunnel_choice in
            1)
                read -p "Enter Iran IP/CIDR (e.g., 192.168.1.0/24 or 1.1.1.1): " iran_ip
                [[ "$iran_ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+(/[0-9]+)?$ ]] && {
                    iptables -t nat -A POSTROUTING -d "$iran_ip" -j ACCEPT
                    echo -e "${GREEN}Iran IP ($iran_ip) is now routed directly!${NC}"
                } || echo -e "${RED}Invalid IP/CIDR format!${NC}"
                ;;
            2)
                read -p "Enter Foreign IP/CIDR (e.g., 8.8.8.8/32): " foreign_ip
                read -p "Enter Gateway/VPN IP (e.g., 10.8.0.1): " gateway_ip
                [[ "$foreign_ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+(/[0-9]+)?$ ]] && \
                [[ "$gateway_ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]] && {
                    ip route add "$foreign_ip" via "$gateway_ip"
                    echo -e "${GREEN}Foreign IP ($foreign_ip) is now routed via $gateway_ip!${NC}"
                } || echo -e "${RED}Invalid IP format!${NC}"
                ;;
            3)
                iptables -t nat -F
                echo -e "${GREEN}IPTable rules have been reset!${NC}"
                ;;
            4)
                return
                ;;
            *)
                echo -e "${RED}Invalid option!${NC}"
                ;;
        esac
        
        read -p "Press [Enter] to continue..."
    done
}

# Reset ALL Changes
reset_all() {
    echo -e "\n${RED}WARNING: This will reset ALL changes made by this script!${NC}"
    read -p "Are you sure you want to continue? [y/N]: " confirm
    [[ "$confirm" != "y" && "$confirm" != "Y" ]] && return

    for iface in "${NETWORK_INTERFACES[@]}"; do
        ip link set dev "$iface" mtu $DEFAULT_MTU 2>/dev/null
    done
    CURRENT_MTU=$DEFAULT_MTU

    echo "nameserver 1.1.1.1" > /etc/resolv.conf
    chmod 644 /etc/resolv.conf
    CURRENT_DNS="1.1.1.1"

    iptables -D INPUT -p icmp --icmp-type echo-request -j DROP 2>/dev/null

    sysctl -w net.ipv6.conf.all.disable_ipv6=0 >/dev/null
    sysctl -w net.ipv6.conf.default.disable_ipv6=0 >/dev/null

    iptables -t nat -F

    sed -i '/# BBR Optimization/,/net.ipv4.tcp_congestion_control=bbr/d' /etc/sysctl.conf
    sysctl -p >/dev/null 2>&1

    rm -f "$CONFIG_FILE"

    echo -e "${GREEN}All changes have been reset to default!${NC}"
}

# Reboot System
reboot_system() {
    echo -e "\n${YELLOW}Rebooting the system...${NC}"
    read -p "Are you sure you want to reboot now? [y/N]: " confirm
    [[ "$confirm" == "y" || "$confirm" == "Y" ]] && {
        echo -e "${GREEN}Rebooting now...${NC}"
        sleep 2
        reboot
    } || echo -e "${YELLOW}Reboot cancelled.${NC}"
}

# Create Emergency Recovery Service
create_recovery_service() {
    cat > /usr/local/bin/network_emergency_recovery <<EOL
#!/bin/bash
# Emergency network recovery
for iface in \$(ls /sys/class/net | grep -v lo); do
    ip link set dev \$iface mtu $DEFAULT_MTU 2>/dev/null
done
echo "nameserver 1.1.1.1" > /etc/resolv.conf
chmod 644 /etc/resolv.conf
iptables -F
if [[ -d /etc/netplan ]]; then
    netplan apply >/dev/null 2>&1
elif [[ -f /etc/network/interfaces ]]; then
    systemctl restart networking >/dev/null 2>&1
fi
EOL

    chmod +x /usr/local/bin/network_emergency_recovery

    cat > /etc/systemd/system/network-recovery.service <<EOL
[Unit]
Description=Network Emergency Recovery
After=network-pre.target
Before=network.target

[Service]
ExecStart=/usr/local/bin/network_emergency_recovery
Type=oneshot
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOL

    systemctl enable network-recovery.service >/dev/null 2>&1
}

# Main Menu
show_menu() {
    check_root
    create_recovery_service
    load_config
    apply_persistent_settings
    
    while true; do
        show_header
        echo -e "${BOLD}Main Menu:${NC}"
        echo -e "1) Install Advanced BBR Optimization"
        echo -e "2) Configure MTU (Current: $CURRENT_MTU)"
        echo -e "3) Configure DNS (Current: ${DNS_SERVERS[*]})"
        echo -e "4) Firewall Management"
        echo -e "5) Reset Network Settings"
        echo -e "6) Manage ICMP Ping"
        echo -e "7) Manage IPv6"
        echo -e "8) Setup IPTable Tunnel"
        echo -e "9) Ping MTU Size Test"
        echo -e "10) Reset ALL Changes"
        echo -e "11) Reboot System"
        echo -e "12) Emergency Recovery Mode"
        echo -e "13) Exit"
        
        read -p "Enter your choice [1-13]: " choice
        
        case $choice in
            1) install_bbr ;;
            2)
                read -p "Enter new MTU value (recommended 1420, Hetzner 1450): " new_mtu
                [[ "$new_mtu" =~ ^[0-9]+$ ]] && [ "$new_mtu" -ge 68 ] && [ "$new_mtu" -le 9000 ] && \
                configure_mtu "$new_mtu" || echo -e "${RED}Invalid MTU value (must be 68-9000)!${NC}"
                ;;
            3)
                read -p "Enter new DNS servers (space separated, recommended 1.1.1.1): " new_dns
                DNS_SERVERS=($new_dns)
                update_dns
                ;;
            4) manage_firewall ;;
            5) reset_network ;;
            6) manage_icmp ;;
            7) manage_ipv6 ;;
            8) manage_tunnel ;;
            9) ping_mtu ;;
            10) reset_all ;;
            11) reboot_system ;;
            12)
                echo -e "\n${RED}EMERGENCY RECOVERY MODE${NC}"
                /usr/local/bin/network_emergency_recovery
                echo -e "${GREEN}Basic network settings restored!${NC}"
                ;;
            13)
                echo -e "${GREEN}Exiting...${NC}"
                exit 0
                ;;
            *)
                echo -e "${RED}Invalid option!${NC}"
                ;;
        esac
        
        read -p "Press [Enter] to continue..."
    done
}

# Start the script
show_menu
