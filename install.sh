#!/bin/bash

# Global Configuration
SCRIPT_NAME="Ultimate Network Optimizer PRO"
SCRIPT_VERSION="10.4"  # Updated version
AUTHOR="Parham Pahlevan"
CONFIG_FILE="/etc/network_optimizer.conf"
LOG_FILE="/var/log/network_optimizer.log"
BACKUP_DIR="/var/lib/network_optimizer"
NETWORK_INTERFACE=$(ip -o -4 route show default | awk '{print $5}' | head -n1)
DEFAULT_MTU=1500
[ -f /proc/xen/xenbus ] && DEFAULT_MTU=1450 # Hetzner adjustment
CURRENT_MTU=$(cat /sys/class/net/$NETWORK_INTERFACE/mtu 2>/dev/null || echo $DEFAULT_MTU)
DNS_SERVERS=("1.1.1.1") # Only use Cloudflare DNS by default
CURRENT_DNS=$(grep nameserver /etc/resolv.conf 2>/dev/null | awk '{print $2}' | tr '\n' ' ')
SAFE_REBOOT=false

# Initialize logging and backup
mkdir -p "$BACKUP_DIR" "$(dirname "$LOG_FILE")"
exec > >(tee -a "$LOG_FILE") 2>&1

# Color Codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'
BOLD='\033[1m'

# Save Configuration
save_config() {
    cat > "$CONFIG_FILE" <<EOL
# Network Optimizer Configuration
NETWORK_INTERFACE="$NETWORK_INTERFACE"
MTU=$CURRENT_MTU
DNS_SERVERS=(${DNS_SERVERS[@]})
EOL
    chmod 600 "$CONFIG_FILE"
}

# Load Configuration
load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        source "$CONFIG_FILE"
        [ -n "$MTU" ] && CURRENT_MTU=$MTU
        [ -n "$DNS_SERVERS" ] && DNS_SERVERS=(${DNS_SERVERS[@]})
        [ -n "$NETWORK_INTERFACE" ] && NETWORK_INTERFACE="$NETWORK_INTERFACE"
    fi
}

# Apply persistent settings after reboot
apply_persistent_settings() {
    # Apply MTU if interface exists and is up
    if [ -n "$NETWORK_INTERFACE" ] && ip link show "$NETWORK_INTERFACE" >/dev/null 2>&1; then
        ip link set dev "$NETWORK_INTERFACE" mtu "$CURRENT_MTU" 2>/dev/null || {
            echo -e "${RED}Failed to apply MTU $CURRENT_MTU to $NETWORK_INTERFACE${NC}"
            CURRENT_MTU=$DEFAULT_MTU
        }
        
        if [[ -d /etc/netplan ]]; then
            local netplan_file=$(ls /etc/netplan/*.yaml | head -n1)
            [ -f "$netplan_file" ] && {
                cp "$netplan_file" "$BACKUP_DIR/netplan_$(date +%s).yaml"
                if ! grep -q "mtu: $CURRENT_MTU" "$netplan_file"; then
                    sed -i "/$NETWORK_INTERFACE:/a\      mtu: $CURRENT_MTU" "$netplan_file" || {
                        echo -e "${RED}Failed to update netplan file${NC}"
                        cp "$BACKUP_DIR/netplan_$(ls -t "$BACKUP_DIR/netplan_*.yaml" | head -1)" "$netplan_file"
                    }
                    netplan apply >/dev/null 2>&1 || {
                        echo -e "${RED}Netplan apply failed${NC}"
                        cp "$BACKUP_DIR/netplan_$(ls -t "$BACKUP_DIR/netplan_*.yaml" | head -1)" "$netplan_file"
                        netplan apply >/dev/null 2>&1
                    }
                fi
            }
        fi
    fi

    # Apply DNS
    if [ ${#DNS_SERVERS[@]} -gt 0 ]; then
        if systemctl is-active --quiet systemd-resolved; then
            for dns in "${DNS_SERVERS[@]}"; do
                resolvectl dns "$NETWORK_INTERFACE" "$dns" >/dev/null 2>&1 || {
                    echo -e "${RED}Failed to set DNS $dns via systemd-resolved${NC}"
                    DNS_SERVERS=("1.1.1.1")
                    resolvectl dns "$NETWORK_INTERFACE" "1.1.1.1" >/dev/null 2>&1
                }
            done
        else
            echo "# Generated by $SCRIPT_NAME" > /etc/resolv.conf
            for dns in "${DNS_SERVERS[@]}"; do
                echo "nameserver $dns" >> /etc/resolv.conf
            done
        fi
        CURRENT_DNS="${DNS_SERVERS[*]}"
    fi
}

# Header Display
show_header() {
    clear
    echo -e "${BLUE}${BOLD}╔════════════════════════════════════════════════╗"
    echo -e "║   ${SCRIPT_NAME} ${SCRIPT_VERSION} - ${AUTHOR}         ║"
    echo -e "╚════════════════════════════════════════════════╝${NC}"
    [ -n "$NETWORK_INTERFACE" ] && echo -e "${YELLOW}Interface: ${BOLD}$NETWORK_INTERFACE${NC}" || echo -e "${YELLOW}Interface: ${RED}Not detected${NC}"
    echo -e "${YELLOW}Current MTU: ${BOLD}$CURRENT_MTU${NC}"
    echo -e "${YELLOW}Current DNS: ${BOLD}$CURRENT_DNS${NC}"

    # Show BBR Status
    local bbr_status=$(sysctl net.ipv4.tcp_congestion_control 2>/dev/null | awk '{print $3}')
    if [[ "$bbr_status" == "bbr" ]]; then
        echo -e "${YELLOW}BBR Status: ${GREEN}Enabled${NC}"
    else
        echo -e "${YELLOW}BBR Status: ${RED}Disabled${NC}"
    fi

    # Show Firewall Status
    if command -v ufw >/dev/null 2>&1; then
        local fw_status=$(ufw status | grep -o "active")
        echo -e "${YELLOW}Firewall Status: ${BOLD}$fw_status${NC}"
    else
        echo -e "${YELLOW}Firewall Status: ${BOLD}Not detected${NC}"
    fi

    # Show ICMP Status
    local icmp_status=$(iptables -L INPUT -n 2>/dev/null | grep "icmp" | grep -o "DROP")
    if [ "$icmp_status" == "DROP" ]; then
        echo -e "${YELLOW}ICMP Ping: ${RED}Blocked${NC}"
    else
        echo -e "${YELLOW}ICMP Ping: ${GREEN}Allowed${NC}"
    fi

    # Show IPv6 Status
    local ipv6_status=$(sysctl net.ipv6.conf.all.disable_ipv6 2>/dev/null | awk '{print $3}')
    if [ "$ipv6_status" == "1" ]; then
        echo -e "${YELLOW}IPv6: ${RED}Disabled${NC}"
    else
        echo -e "${YELLOW}IPv6: ${GREEN}Enabled${NC}"
    fi
    echo
}

# Check Root
check_root() {
    if [[ $EUID -ne 0 ]]; then
        echo -e "${RED}Error: This script must be run as root!${NC}"
        exit 1
    fi
}

# Test Connectivity
_test_connectivity() {
    local targets=("1.1.1.1" "8.8.8.8")
    for target in "${targets[@]}"; do
        if ping -c 2 -W 3 "$target" >/dev/null 2>&1; then
            return 0
        fi
    done
    return 1
}

# Ping with Custom MTU
ping_mtu() {
    read -p "Enter MTU size to test (e.g., 1420): " test_mtu
    if [[ "$test_mtu" =~ ^[0-9]+$ ]] && [ "$test_mtu" -ge 68 ] && [ "$test_mtu" -le 9000 ]; then
        echo -e "${YELLOW}Testing ping with MTU=$test_mtu...${NC}"
        ping -M do -s $((test_mtu - 28)) -c 4 1.1.1.1
    else
        echo -e "${RED}Invalid MTU value (must be 68-9000)!${NC}"
    fi
}

# Validate MTU
validate_mtu() {
    local mtu=$1
    # Test MTU by sending a packet with the specified size
    if ping -M do -s $((mtu - 28)) -c 2 1.1.1.1 >/dev/null 2>&1; then
        return 0
    else
        echo -e "${RED}MTU $mtu is not supported by the network${NC}"
        return 1
    fi
}

# Configure MTU
configure_mtu() {
    local new_mtu=$1
    local old_mtu=$(cat /sys/class/net/$NETWORK_INTERFACE/mtu 2>/dev/null || echo $DEFAULT_MTU)

    if ! [[ "$new_mtu" =~ ^[0-9]+$ ]] || [ "$new_mtu" -lt 68 ] || [ "$new_mtu" -gt 9000 ]; then
        echo -e "${RED}MTU must be between 68 and 9000!${NC}"
        return 1
    fi

    # Validate MTU before applying
    if ! validate_mtu "$new_mtu"; then
        return 1
    fi

    # Backup current settings
    local backup_file="$BACKUP_DIR/mtu_backup_$(date +%s).conf"
    ip -o link show > "$backup_file"

    # Set temporary MTU
    if ! ip link set dev "$NETWORK_INTERFACE" mtu "$new_mtu"; then
        echo -e "${RED}Failed to set temporary MTU!${NC}"
        return 1
    fi

    # Test connectivity
    if ! _test_connectivity; then
        echo -e "${RED}Connectivity test failed! Rolling back MTU...${NC}"
        ip link set dev "$NETWORK_INTERFACE" mtu "$old_mtu"
        /usr/local/bin/network_emergency_recovery
        return 1
    fi

    # Apply persistent configuration for netplan only (Ubuntu-specific)
    if [[ -d /etc/netplan ]]; then
        local netplan_file=$(ls /etc/netplan/*.yaml | head -n1)
        [ -f "$netplan_file" ] && {
            cp "$netplan_file" "$BACKUP_DIR/netplan_$(date +%s).yaml"
            if ! grep -q "mtu: $new_mtu" "$netplan_file"; then
                sed -i "/$NETWORK_INTERFACE:/a\      mtu: $new_mtu" "$netplan_file" || {
                    echo -e "${RED}Failed to update netplan file${NC}"
                    cp "$BACKUP_DIR/netplan_$(ls -t "$BACKUP_DIR/netplan_*.yaml" | head -1)" "$netplan_file"
                    return 1
                }
                netplan apply >/dev/null 2>&1 || {
                    echo -e "${RED}Failed to apply netplan! Restoring backup...${NC}"
                    cp "$BACKUP_DIR/netplan_$(ls -t "$BACKUP_DIR/netplan_*.yaml" | head -1)" "$netplan_file"
                    netplan apply >/dev/null 2>&1
                    return 1
                }
            fi
        }
    fi

    CURRENT_MTU=$new_mtu
    save_config
    echo -e "${GREEN}MTU successfully set to $new_mtu (persistent after reboot)${NC}"
    return 0
}

# Update DNS Configuration
update_dns() {
    # Validate DNS servers
    local working_dns=()
    for dns in "${DNS_SERVERS[@]}"; do
        if [[ "$dns" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]] && timeout 2 dig +short @$dns google.com >/dev/null; then
            working_dns+=("$dns")
        else
            echo -e "${YELLOW}Warning: DNS server $dns is invalid or not responding${NC}"
        fi
    done

    if [ ${#working_dns[@]} -eq 0 ]; then
        echo -e "${RED}Error: No working DNS servers found! Reverting to 1.1.1.1${NC}"
        working_dns=("1.1.1.1")
    fi

    DNS_SERVERS=("${working_dns[@]}")

    # Backup current resolv.conf
    cp /etc/resolv.conf "$BACKUP_DIR/resolv.conf.bak.$(date +%s)" 2>/dev/null

    # Apply DNS settings
    if systemctl is-active --quiet systemd-resolved; then
        rm -f /etc/resolv.conf
        ln -sf /run/systemd/resolve/resolv.conf /etc/resolv.conf
        for dns in "${DNS_SERVERS[@]}"; do
            resolvectl dns "$NETWORK_INTERFACE" "$dns" >/dev/null 2>&1 || {
                echo -e "${RED}Failed to set DNS $dns${NC}"
                DNS_SERVERS=("1.1.1.1")
                resolvectl dns "$NETWORK_INTERFACE" "1.1.1.1" >/dev/null 2>&1
                return 1
            }
        done
    else
        echo "# Generated by $SCRIPT_NAME" > /etc/resolv.conf
        for dns in "${DNS_SERVERS[@]}"; do
            echo "nameserver $dns" >> /etc/resolv.conf
        done
    fi

    # Test connectivity
    if ! _test_connectivity; then
        echo -e "${RED}Connectivity lost after DNS change! Restoring previous settings...${NC}"
        cp "$BACKUP_DIR/resolv.conf.bak.$(ls -t "$BACKUP_DIR/resolv.conf.bak.*" | head -1)" /etc/resolv.conf 2>/dev/null
        DNS_SERVERS=("1.1.1.1")
        echo -e "${YELLOW}Reverted to default DNS (1.1.1.1)${NC}"
    fi

    CURRENT_DNS="${DNS_SERVERS[*]}"
    save_config
    echo -e "${GREEN}DNS servers updated successfully (persistent after reboot)${NC}"
}

# Enhanced BBR Installation
install_bbr() {
    # Check if BBR is supported
    if ! lsmod | grep -q tcp_bbr; then
        modprobe tcp_bbr 2>/dev/null || {
            echo -e "${RED}BBR is not supported by this kernel!${NC}"
            return 1
        }
    fi

    # Check if fq qdisc is supported
    if ! tc qdisc show | grep -q fq; then
        tc qdisc add dev "$NETWORK_INTERFACE" root fq 2>/dev/null || {
            echo -e "${RED}Fair Queue (fq) qdisc is not supported!${NC}"
            return 1
        }
        tc qdisc del dev "$NETWORK_INTERFACE" root fq 2>/dev/null
    fi

    # Backup current sysctl settings
    cp /etc/sysctl.conf "$BACKUP_DIR/sysctl.conf.bak.$(date +%s)"

    # List of parameters to apply
    local sysctl_params=(
        "net.core.default_qdisc=fq"
        "net.ipv4.tcp_congestion_control=bbr"
        "net.ipv4.tcp_fastopen=3"
        "net.ipv4.tcp_syncookies=1"
        "net.ipv4.tcp_tw_reuse=1"
        "net.ipv4.tcp_fin_timeout=30"
        "net.ipv4.tcp_keepalive_time=1200"
        "net.ipv4.ip_local_port_range=1024 65000"
        "net.ipv4.tcp_max_syn_backlog=8192"
        "net.ipv4.tcp_max_tw_buckets=5000"
        "net.core.somaxconn=65535"
        "net.core.netdev_max_backlog=16384"
        "net.ipv4.tcp_slow_start_after_idle=0"
        "net.ipv4.tcp_mtu_probing=1"
        "net.ipv4.tcp_rfc1337=1"
    )

    # Apply settings temporarily and validate
    for param in "${sysctl_params[@]}"; do
        if ! sysctl -w "$param" >/dev/null 2>&1; then
            echo -e "${RED}Failed to set $param!${NC}"
            cp "$BACKUP_DIR/sysctl.conf.bak.$(ls -t "$BACKUP_DIR/sysctl.conf.bak.*" | head -1)" /etc/sysctl.conf
            sysctl -p >/dev/null 2>&1
            /usr/local/bin/network_emergency_recovery
            return 1
        fi
    done

    # Test connectivity after temporary changes
    if ! _test_connectivity; then
        echo -e "${RED}Connectivity lost after applying BBR settings! Restoring previous settings...${NC}"
        cp "$BACKUP_DIR/sysctl.conf.bak.$(ls -t "$BACKUP_DIR/sysctl.conf.bak.*" | head -1)" /etc/sysctl.conf
        sysctl -p >/dev/null 2>&1
        /usr/local/bin/network_emergency_recovery
        return 1
    fi

    # Apply settings persistently
    {
        echo "# BBR Optimization"
        for param in "${sysctl_params[@]}"; do
            echo "$param"
        done
    } >> /etc/sysctl.conf

    # Apply persistent settings
    if ! sysctl -p >/dev/null 2>&1; then
        echo -e "${RED}Error applying BBR settings persistently! Restoring backup...${NC}"
        cp "$BACKUP_DIR/sysctl.conf.bak.$(ls -t "$BACKUP_DIR/sysctl.conf.bak.*" | head -1)" /etc/sysctl.conf
        sysctl -p >/dev/null 2>&1
        /usr/local/bin/network_emergency_recovery
        return 1
    fi

    # Verify BBR
    local current_cc=$(sysctl net.ipv4.tcp_congestion_control | awk '{print $3}')
    if [[ "$current_cc" == "bbr" ]]; then
        echo -e "${GREEN}BBR and TCP optimizations successfully installed${NC}"
        return 0
    else
        echo -e "${RED}Failed to enable BBR!${NC}"
        cp "$BACKUP_DIR/sysctl.conf.bak.$(ls -t "$BACKUP_DIR/sysctl.conf.bak.*" | head -1)" /etc/sysctl.conf
        sysctl -p >/dev/null 2>&1
        /usr/local/bin/network_emergency_recovery
        return 1
    fi
}

# Firewall Management
manage_firewall() {
    echo -e "\n${YELLOW}Firewall Management${NC}"
    echo -e "1) Enable Firewall"
    echo -e "2) Disable Firewall"
    echo -e "3) Open Port"
    echo -e "4) Close Port"
    echo -e "5) List Open Ports"
    echo -e "6) Back to Main Menu"
    
    read -p "Enter your choice [1-6]: " fw_choice
    
    case $fw_choice in
        1)
            if command -v ufw >/dev/null 2>&1; then
                ufw enable
                echo -e "${GREEN}UFW firewall has been enabled${NC}"
            else
                echo -e "${RED}UFW not detected!${NC}"
            fi
            ;;
        2)
            if command -v ufw >/dev/null 2>&1; then
                ufw disable
                echo -e "${GREEN}UFW firewall has been disabled${NC}"
            else
                echo -e "${RED}UFW not detected!${NC}"
            fi
            ;;
        3)
            read -p "Enter port number to open (e.g., 22): " port
            if ! [[ "$port" =~ ^[0-9]+$ ]] || [ "$port" -lt 1 ] || [ "$port" -gt 65535 ]; then
                echo -e "${RED}Invalid port number (1-65535)!${NC}"
                manage_firewall
                return
            fi
            
            read -p "Enter protocol (tcp/udp, default is tcp): " protocol
            protocol=${protocol:-tcp}
            
            if [[ "$protocol" != "tcp" && "$protocol" != "udp" ]]; then
                echo -e "${RED}Protocol must be tcp or udp!${NC}"
                manage_firewall
                return
            fi
            
            if command -v ufw >/dev/null 2>&1; then
                ufw allow $port/$protocol
                echo -e "${GREEN}Port $port/$protocol has been opened in UFW${NC}"
            else
                echo -e "${RED}UFW not detected!${NC}"
            fi
            ;;
        4)
            read -p "Enter port number to close (e.g., 22): " port
            if ! [[ "$port" =~ ^[0-9]+$ ]] || [ "$port" -lt 1 ] || [ "$port" -gt 65535 ]; then
                echo -e "${RED}Invalid port number (1-65535)!${NC}"
                manage_firewall
                return
            fi
            
            read -p "Enter protocol (tcp/udp, default is tcp): " protocol
            protocol=${protocol:-tcp}
            
            if [[ "$protocol" != "tcp" && "$protocol" != "udp" ]]; then
                echo -e "${RED}Protocol must be tcp or udp!${NC}"
                manage_firewall
                return
            fi
            
            if command -v ufw >/dev/null 2>&1; then
                ufw deny $port/$protocol
                echo -e "${GREEN}Port $port/$protocol has been closed in UFW${NC}"
            else
                echo -e "${RED}UFW not detected!${NC}"
            fi
            ;;
        5)
            if command -v ufw >/dev/null 2>&1; then
                echo -e "\n${YELLOW}UFW Open Ports:${NC}"
                ufw status verbose
            else
                echo -e "${RED}UFW not detected!${NC}"
            fi
            ;;
        6)
            return
            ;;
        *)
            echo -e "${RED}Invalid option!${NC}"
            ;;
    esac
    
    read -p "Press [Enter] to continue..."
    manage_firewall
}

# Reset Network Settings
reset_network() {
    echo -e "\n${YELLOW}Resetting network settings...${NC}"
    if [[ -d /etc/netplan ]]; then
        netplan apply >/dev/null 2>&1
    fi
    echo -e "${GREEN}Network services have been restarted${NC}"
}

# ICMP Ping Management
manage_icmp() {
    echo -e "\n${YELLOW}ICMP Ping Management${NC}"
    echo -e "1) Block ICMP Ping (Disable Ping)"
    echo -e "2) Allow ICMP Ping (Enable Ping)"
    echo -e "3) Back to Main Menu"
    
    read -p "Enter your choice [1-3]: " icmp_choice
    
    case $icmp_choice in
        1)
            iptables -A INPUT -p icmp --icmp-type echo-request -j DROP
            echo -e "${GREEN}ICMP Ping is now BLOCKED!${NC}"
            ;;
        2)
            iptables -D INPUT -p icmp --icmp-type echo-request -j DROP 2>/dev/null
            echo -e "${GREEN}ICMP Ping is now ALLOWED!${NC}"
            ;;
        3)
            return
            ;;
        *)
            echo -e "${RED}Invalid option!${NC}"
            ;;
    esac
    
    read -p "Press [Enter] to continue..."
    manage_icmp
}

# IPv6 Management
manage_ipv6() {
    echo -e "\n${YELLOW}IPv6 Management${NC}"
    echo -e "1) Disable IPv6"
    echo -e "2) Enable IPv6"
    echo -e "3) Back to Main Menu"
    
    read -p "Enter your choice [1-3]: " ipv6_choice
    
    case $ipv6_choice in
        1)
            sysctl -w net.ipv6.conf.all.disable_ipv6=1 >/dev/null
            sysctl -w net.ipv6.conf.default.disable_ipv6=1 >/dev/null
            echo -e "${GREEN}IPv6 has been DISABLED!${NC}"
            ;;
        2)
            sysctl -w net.ipv6.conf.all.disable_ipv6=0 >/dev/null
            sysctl -w net.ipv6.conf.default.disable_ipv6=0 >/dev/null
            echo -e "${GREEN}IPv6 has been ENABLED!${NC}"
            ;;
        3)
            return
            ;;
 Ascending...
    esac
    
    read -p "Press [Enter] to continue..."
    manage_ipv6
}

# IPTable Tunnel Setup
manage_tunnel() {
    echo -e "\n${YELLOW}IPTable Tunnel Setup${NC}"
    echo -e "1) Route Iranian IPs directly"
    echo -e "2) Route Foreign IPs via VPN/Gateway"
    echo -e "3) Reset IPTable Rules"
    echo -e "4) Back to Main Menu"
    
    read -p "Enter your choice [1-4]: " tunnel_choice
    
    case $tunnel_choice in
        1)
            read -p "Enter Iran IP/CIDR (e.g., 192.168.1.0/24 or 1.1.1.1): " iran_ip
            if [[ "$iran_ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+(/[0-9]+)?$ ]]; then
                iptables -t nat -A POSTROUTING -d "$iran_ip" -j ACCEPT
                echo -e "${GREEN}Iran IP ($iran_ip) is now routed directly!${NC}"
            else
                echo -e "${RED}Invalid IP/CIDR format!${NC}"
            fi
            ;;
        2)
            read -p "Enter Foreign IP/CIDR (e.g., 8.8.8.8/32): " foreign_ip
            read -p "Enter Gateway/VPN IP (e.g., 10.8.0.1): " gateway_ip
            if [[ "$foreign_ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+(/[0-9]+)?$ ]] && 
               [[ "$gateway_ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                ip route add "$foreign_ip" via "$gateway_ip"
                echo -e "${GREEN}Foreign IP ($foreign_ip) is now routed via $gateway_ip!${NC}"
            else
                echo -e "${RED}Invalid IP format!${NC}"
            fi
            ;;
        3)
            iptables -t nat -F
            echo -e "${GREEN}IPTable rules have been reset!${NC}"
            ;;
        4)
            return
            ;;
        *)
            echo -e "${RED}Invalid option!${NC}"
            ;;
    esac
    
    read -p "Press [Enter] to continue..."
    manage_tunnel
}

# Reset ALL Changes
reset_all() {
    echo -e "\n${RED}WARNING: This will reset ALL changes made by this script!${NC}"
    read -p "Are you sure you want to continue? [y/N]: " confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        return
    fi

    # Reset MTU
    ip link set dev "$NETWORK_INTERFACE" mtu $DEFAULT_MTU 2>/dev/null
    CURRENT_MTU=$DEFAULT_MTU

    # Reset DNS
    echo "nameserver 1.1.1.1" > /etc/resolv.conf
    CURRENT_DNS="1.1.1.1"

    # Reset ICMP
    iptables -D INPUT -p icmp --icmp-type echo-request -j DROP 2>/dev/null

    # Reset IPv6
    sysctl -w net.ipv6.conf.all.disable_ipv6=0 >/dev/null
    sysctl -w net.ipv6.conf.default.disable_ipv6=0 >/dev/null

    # Reset IPTables
    iptables -t nat -F

    # Remove BBR and TCP settings
    sed -i '/# BBR Optimization/,/net.ipv4.tcp_rfc1337=1/d' /etc/sysctl.conf
    sysctl -p >/dev/null 2>&1

    # Remove config file
    rm -f "$CONFIG_FILE"

    echo -e "${GREEN}All changes have been reset to default!${NC}"
}

# Reboot System
reboot_system() {
    echo -e "\n${YELLOW}Rebooting the system...${NC}"
    read -p "Are you sure you want to reboot now? [y/N]: " confirm
    if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
        echo -e "${GREEN}Rebooting now...${NC}"
        sleep 2
        reboot
    else
        echo -e "${YELLOW}Reboot cancelled.${NC}"
    fi
}

# Create Emergency Recovery Service
create_recovery_service() {
    cat > /usr/local/bin/network_emergency_recovery <<EOL
#!/bin/bash
# Emergency network recovery
ip link set dev $NETWORK_INTERFACE mtu $DEFAULT_MTU 2>/dev/null
echo "nameserver 1.1.1.1" > /etc/resolv.conf
iptables -F
# Restart network services
if [[ -d /etc/netplan ]]; then
    netplan apply >/dev/null 2>&1
fi
EOL

    chmod +x /usr/local/bin/network_emergency_recovery

    cat > /etc/systemd/system/network-recovery.service <<EOL
[Unit]
Description=Network Emergency Recovery
After=network-pre.target
Before=network.target

[Service]
ExecStart=/usr/local/bin/network_emergency_recovery
Type=oneshot
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOL

    systemctl enable network-recovery.service >/dev/null 2>&1
}

# Main Menu
show_menu() {
    load_config
    apply_persistent_settings
    
    while true; do
        show_header
        echo -e "${BOLD}Main Menu:${NC}"
        echo -e "1) Install Advanced BBR Optimization"
        echo -e "2) Configure MTU (Current: $CURRENT_MTU)"
        echo -e "3) Configure DNS (Current: ${DNS_SERVERS[*]})"
        echo -e "4) Firewall Management"
        echo -e "5) Reset Network Settings"
        echo -e "6) Manage ICMP Ping"
        echo -e "7) Manage IPv6"
        echo -e "8) Setup IPTable Tunnel"
        echo -e "9) Ping MTU Size Test"
        echo -e "10) Reset ALL Changes"
        echo -e "11) Reboot System"
        echo -e "12) Emergency Recovery Mode"
        echo -e "13) Exit"
        
        read -p "Enter your choice [1-13]: " choice
        
        case $choice in
            1) install_bbr ;;
            2)
                read -p "Enter new MTU value (recommended 1420, Hetzner 1450): " new_mtu
                if [[ "$new_mtu" =~ ^[0-9]+$ ]] && [ "$new_mtu" -ge 68 ] && [ "$new_mtu" -le 9000 ]; then
                    configure_mtu "$new_mtu"
                else
                    echo -e "${RED}Invalid MTU value (must be 68-9000)!${NC}"
                fi
                ;;
            3)
                read -p "Enter new DNS servers (space separated, recommended 1.1.1.1): " new_dns
                DNS_SERVERS=($new_dns)
                update_dns
                ;;
            4) manage_firewall ;;
            5) reset_network ;;
            6) manage_icmp ;;
            7) manage_ipv6 ;;
            8) manage_tunnel ;;
            9) ping_mtu ;;
            10) reset_all ;;
            11) reboot_system ;;
            12)
                echo -e "\n${RED}EMERGENCY RECOVERY MODE${NC}"
                /usr/local/bin/network_emergency_recovery
                echo -e "${GREEN}Basic network settings restored!${NC}"
                ;;
            13)
                echo -e "${GREEN}Exiting...${NC}"
                exit 0
                ;;
            *)
                echo -e "${RED}Invalid option!${NC}"
                ;;
        esac
        
        read -p "Press [Enter] to continue..."
    done
}

# Main Execution
check_root
create_recovery_service
show_menu
